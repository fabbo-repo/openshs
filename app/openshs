#!/bin/env python

import subprocess
import csv
from repeater import SamplesPool
from datetime import datetime, timedelta, time
from glob import glob
import click
import os
import shutil
from collections import OrderedDict
from indexed import IndexedOrderedDict
import itertools
from random import randrange, choice
import json

CONTEXTS = IndexedOrderedDict()
CONFIG_PATH = os.path.join('config','config.json')
CONFIG = {}

# Contexts are loaded from blender directory as files with .blend extension
file_list = os.listdir('blender')
for f in file_list :
    if os.path.isfile(os.path.join('blender', f)) and f.lower().endswith('.blend') \
        and not f.lower().startswith('apartment'):
        context = f.replace('.blend','')
        CONTEXTS[context] = {'exe': os.path.join('blender',f),
                                'start_dt': datetime.strptime("2016-02-01 08-00-00", "%Y-%m-%d %H-%M-%S")}

def validate_dt(value):
    try:
        # The string value of the variable "value" contains or may contain 
        # ':' characters that must be replaced by '-'
        dt = datetime.strptime(str(value).replace(':','-'), 
            "%Y-%m-%d %H-%M-%S")
        return dt
    except ValueError:
        raise click.BadParameter("Please enter a valid datetime")

def validate_date(value):
    try:
        dt = datetime.strptime(value, "%Y-%m-%d")
        return dt
    except ValueError:
        raise click.BadParameter("Please enter a valid date")

def random_timestamp(dt, pool_files, time_margin):
    pool_times = [x[x.find(' ')+1:-4] for x in pool_files]
    times = [datetime.strptime(x, "%H-%M-%S") for x in pool_times]
    random_sample = choice(times)
    if time_margin > 0:
        margin = timedelta(seconds=time_margin * 60)
        random_sample = random_date(random_sample - (margin/2), random_sample + (margin/2))
    new_dt = datetime(dt.year, dt.month, dt.day, random_sample.hour, random_sample.minute, random_sample.second)
    return new_dt

def random_date(start, end):
    delta = end - start
    int_delta = (delta.days * 24 * 60 * 60) + delta.seconds
    random_second = randrange(int_delta)
    return start + timedelta(seconds=random_second)

def add_timestamp_field(reader, start_dt):
    if type(start_dt) is str:
        start_dt = datetime.strptime(start_dt, "%Y-%m-%d %H-%M-%S")
    ts = start_dt
    asec = timedelta(seconds=1)
    result = []

    for i in reader:
        row = i + [ts.strftime("%Y-%m-%d %H-%M-%S")]
        result.append(row)
        ts += asec
    return result

def is_weekday(dt):
    if dt.weekday() < 5:
        return True
    else:
        return False


@click.group()
def main():
    """OpenSHS: Open Smart Home Simulator"""
    pass


@main.command()
@click.option('--list-contexts', '-lc', default=False, is_flag=True, help='Lists the available contexts.')
@click.option('--recorded-samples', '-rs', default=False, is_flag=True, help='Shows the status of the recorded contexts samples.')
def status(list_contexts, recorded_samples):
    """Shows the current status of the experiment."""
    if list_contexts:
        click.echo(", ".join([x for x in CONTEXTS.keys()]))

    if recorded_samples:
        for context in CONTEXTS:
            files = glob(os.path.join('data','*_') + context + '_*.csv')
            weekdays = str(len([f for f in files if f.split(os.path.join('data',''))[1].startswith('weekday')]))
            weekends = str(len([f for f in files if f.split(os.path.join('data',''))[1].startswith('weekend')]))
            click.echo("For context " + click.style(context, bold=True) + ", " + click.style('weekdays', bold=True) + ": " + weekdays + " Samples.")
            click.echo("For context " + click.style(context, bold=True) + ", " + click.style('weekends', bold=True) + ": " + weekends + " Samples.")


@main.command()
@click.option('--context', '-c', type=click.Choice(list(CONTEXTS.keys())), help='Which context to start.')
@click.option('--primusrun', '-p', default=False, is_flag=True, help='Start the context with primus support (Linux Only).')
def start(context, primusrun):
    """Start a context experiment."""
    click.echo('Starting the ' + click.style(context, bold=True) + ' context.')
    start_dt = click.prompt("What's the starting time?",
                            default=CONTEXTS[context]['start_dt'],
                            value_proc=validate_dt)

    CONTEXTS[context]['start_dt'] = start_dt

    weekday_p = is_weekday(start_dt)

    # Write the starting datetime for blender to read
    CONFIG['start_time'] = int(start_dt.timestamp())
    # Serializing json 
    json_object = json.dumps(CONFIG, indent = 4)
    # Writing to sample.json
    with open(CONFIG_PATH, "w") as json_file:
        json_file.write(json_object)

    if primusrun:
        subprocess.call(["primusrun", "blender", CONTEXTS[context]['exe']], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    else:
        subprocess.call(["blender", CONTEXTS[context]['exe']], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    # After the simulation is complete, data stored in the output.csv file must be saved
    count = 0
    while True:
        try:
            data_week_csv = os.path.join('data', 
                ('weekday_' if weekday_p else 'weekend_') + context + '_' + datetime.strftime(start_dt, "%Y-%m-%d %H-%M-%S") +
                ('' if not count else '_' + str(count) ) + '.csv')
            data_out_csv = os.path.join('temp', 'output.csv')
            os.rename(data_out_csv, data_week_csv)
            click.echo('Dataset saved as  ' + data_week_csv); break
        except FileExistsError:
            click.echo('File ' + data_week_csv +  ' already exists')
            count+=1
        except FileNotFoundError:
            click.echo('Ungenerated dataset'); break

@main.command()
@click.option('--days', '-d', type=int, default=30, help='How many days to generate.')
@click.option('--start-date', '-sd', type=validate_date, help='The starting date for the aggregated dataset.')
@click.option('--time-margin', '-tm', type=int, default=0, help='The starting time margin for each replicated sample.')
@click.option('--variable-activities', '-va', default=False, is_flag=True, help='Make the activities duration variable.')
def aggregate(days, start_date, time_margin, variable_activities):
    """Aggregate the datasets."""

    files = glob(os.path.join('data','*.csv'))

    aday = timedelta(days=1)
    dt = start_date

    # The header row
    with open(files[0], 'r') as headfile:
        csv_reader = csv.reader(headfile)
        header = next(csv_reader)
    header.append('timestamp')

    d_rows = []
    with open(os.path.join('datasets','dataset.csv'), 'w') as outf:
        csv_writer = csv.writer(outf)
        csv_writer.writerow(header)

        for _ in range(days):
            if is_weekday(dt):
                for context in CONTEXTS:
                    pool_files = glob('data/weekday_' + context + '*.csv')
                    pool = SamplesPool(pool_files, variable_activities)
                    rep_rows = pool.generate_sample(header=False)
                    d_rows += add_timestamp_field(rep_rows, random_timestamp(dt, pool_files, time_margin))
            else:
                for context in CONTEXTS:
                    pool_files = glob('data/weekend_' + context + '*.csv')
                    pool = SamplesPool(pool_files, variable_activities)
                    rep_rows = pool.generate_sample(header=False)
                    d_rows += add_timestamp_field(rep_rows, random_timestamp(dt, pool_files, time_margin))
            dt += aday

        csv_writer.writerows(d_rows)


if __name__ == '__main__':
    main()
